<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ADAM'S PAC-MAN CHALLENGE</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --pac-yellow: #FFFF00;
            --ghost-red: #FF0000;
            --ghost-pink: #FFB8FF;
            --ghost-cyan: #00FFFF;
            --ghost-orange: #FFB852;
            --wall-blue: #1919A6;
            --bg-black: #000000;
        }

        body {
            background-color: var(--bg-black);
            color: #FFFFFF;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        #game-area {
            position: relative;
            width: 100%;
            max-width: 400px;
            text-align: center;
        }

        canvas {
            background-color: #000;
            display: block;
            margin: 0 auto;
            border: 2px solid var(--wall-blue);
            box-shadow: 0 0 10px var(--wall-blue);
        }

        #game-ui {
            display: flex;
            justify-content: space-between;
            width: 380px;
            margin: 0 auto 10px auto;
            font-size: 12px;
            color: var(--pac-yellow);
        }

        #game-instructions {
            font-size: 10px;
            color: #888;
            margin-top: 15px;
            text-transform: uppercase;
        }

        .back-btn {
            margin-top: 20px;
            padding: 15px 30px;
            border: 2px solid #FFF;
            background: #000;
            color: #FFF;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
        }
        .back-btn:hover { background: #FFF; color: #000; }

    </style>
</head>
<body>

    <div id="game-ui">
        <div id="score-display">SCORE: 0</div>
        <div>PLAYER: ADAM</div>
    </div>

    <div id="game-area">
        <canvas id="gameCanvas" width="380" height="300"></canvas>
    </div>

    <div id="game-instructions">ARROWS OR SWIPE TO MOVE</div>

    <a href="index.html" class="back-btn">BACK TO MENU</a>

    <script>
        // --- GAME ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 20;
        const COLS = 19;
        const ROWS = 15;
        let gameRunning = false;
        let score = 0;

        // Map: 1=Wall, 0=Dot, 2=Empty/PacStart, 9=GhostStart
        const mapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,9,2,9,2,2,1,0,1,2,2,2], 
            [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1], 
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let walls = [];
        let dots = [];
        // SLOWER SPEED SET HERE: 0.075
        let pacman = { x: 9, y: 13, dir: 4, nextDir: 4, speed: 0.075, moveProgress: 0, currentX: 9, currentY: 13 };
        let ghosts = [
            { x: 9, y: 7, color: 'red', dir: 1, speed: 0.05, moveProgress: 0, currentX: 9, currentY: 7 },
            { x: 10, y: 7, color: 'pink', dir: 3, speed: 0.05, moveProgress: 0, currentX: 10, currentY: 7 }
        ];
        
        let touchStartX = 0;
        let touchStartY = 0;

        function initGame() {
            resetLevel();
            score = 0;
            updateScore();
            gameRunning = true;
            
            window.addEventListener('keydown', handleInput);
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            
            requestAnimationFrame(gameLoop);
        }

        function resetLevel() {
            walls = [];
            dots = [];
            for(let r=0; r<ROWS; r++){
                for(let c=0; c<COLS; c++){
                    if(mapLayout[r][c] === 1) walls.push({x:c, y:r});
                    if(mapLayout[r][c] === 0) dots.push({x:c, y:r, active:true});
                }
            }
            pacman = { x: 9, y: 13, dir: 4, nextDir: 4, speed: 0.075, moveProgress: 0, currentX: 9, currentY: 13 };
            ghosts = [
                { x: 9, y: 7, color: 'red', dir: 1, speed: 0.05, moveProgress: 0, currentX: 9, currentY: 7 },
                { x: 10, y: 7, color: 'pink', dir: 3, speed: 0.05, moveProgress: 0, currentX: 10, currentY: 7 }
            ];
        }

        function handleInput(e) {
            if([37,38,39,40].indexOf(e.keyCode) > -1) e.preventDefault();
            if(e.keyCode === 38) pacman.nextDir = 0; 
            if(e.keyCode === 39) pacman.nextDir = 1; 
            if(e.keyCode === 40) pacman.nextDir = 2; 
            if(e.keyCode === 37) pacman.nextDir = 3; 
        }

        function handleTouchStart(e) {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if(!touchStartX || !touchStartY) return;
            let touchEndX = e.touches[0].clientX;
            let touchEndY = e.touches[0].clientY;
            let dx = touchEndX - touchStartX;
            let dy = touchEndY - touchStartY;
            
            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0) pacman.nextDir = 1; 
                    else pacman.nextDir = 3;
                } else {
                    if (dy > 0) pacman.nextDir = 2; 
                    else pacman.nextDir = 0;
                }
                touchStartX = touchEndX;
                touchStartY = touchEndY;
            }
        }

        function gameLoop() {
            if(!gameRunning) return;
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            moveEntity(pacman, true);
            ghosts.forEach(g => {
                if (g.moveProgress === 0 && isIntersection(g.x, g.y)) {
                    const dirs = getValidDirections(g.x, g.y);
                    g.dir = dirs[Math.floor(Math.random() * dirs.length)];
                }
                if (isBlocked(g.x, g.y, g.dir) && g.moveProgress === 0) {
                     const dirs = getValidDirections(g.x, g.y);
                     g.dir = dirs[Math.floor(Math.random() * dirs.length)];
                }
                moveEntity(g, false);
            });

            ghosts.forEach(g => {
                const dist = Math.hypot(pacman.currentX - g.currentX, pacman.currentY - g.currentY);
                if(dist < 0.5) gameOver();
            });

            dots.forEach(d => {
                if(d.active) {
                    const dist = Math.hypot(pacman.currentX - d.x, pacman.currentY - d.y);
                    if(dist < 0.5) {
                        d.active = false;
                        score += 10;
                        updateScore();
                        checkWin();
                    }
                }
            });
        }

        function moveEntity(e, isPlayer) {
            if (e.moveProgress > 0) {
                e.moveProgress += e.speed;
                if (e.moveProgress >= 1) {
                    e.moveProgress = 0;
                    if(e.dir === 0) e.y--;
                    if(e.dir === 1) e.x++;
                    if(e.dir === 2) e.y++;
                    if(e.dir === 3) e.x--;
                    e.currentX = e.x;
                    e.currentY = e.y;
                    if(isPlayer) {
                        if(e.nextDir !== 4 && !isBlocked(e.x, e.y, e.nextDir)) e.dir = e.nextDir;
                        else if (isBlocked(e.x, e.y, e.dir)) e.dir = 4;
                    }
                } else {
                    if(e.dir === 0) e.currentY = e.y - e.moveProgress;
                    if(e.dir === 1) e.currentX = e.x + e.moveProgress;
                    if(e.dir === 2) e.currentY = e.y + e.moveProgress;
                    if(e.dir === 3) e.currentX = e.x - e.moveProgress;
                }
            } else {
                if(isPlayer && e.nextDir !== 4 && !isBlocked(e.x, e.y, e.nextDir)) e.dir = e.nextDir;
                if (e.dir !== 4 && !isBlocked(e.x, e.y, e.dir)) e.moveProgress += e.speed;
            }
        }

        function isBlocked(x, y, dir) {
            let nextX = x, nextY = y;
            if(dir === 0) nextY--;
            if(dir === 1) nextX++;
            if(dir === 2) nextY++;
            if(dir === 3) nextX--;
            if(nextX < 0 || nextX >= COLS || nextY < 0 || nextY >= ROWS) return true;
            return walls.some(w => w.x === nextX && w.y === nextY);
        }

        function isIntersection(x, y) {
            let open = 0;
            if(!isBlocked(x, y, 0)) open++;
            if(!isBlocked(x, y, 1)) open++;
            if(!isBlocked(x, y, 2)) open++;
            if(!isBlocked(x, y, 3)) open++;
            return open > 2;
        }

        function getValidDirections(x, y) {
            const dirs = [];
            if(!isBlocked(x, y, 0)) dirs.push(0);
            if(!isBlocked(x, y, 1)) dirs.push(1);
            if(!isBlocked(x, y, 2)) dirs.push(2);
            if(!isBlocked(x, y, 3)) dirs.push(3);
            return dirs;
        }

        function draw() {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#1919A6";
            walls.forEach(w => ctx.fillRect(w.x * TILE_SIZE, w.y * TILE_SIZE, TILE_SIZE, TILE_SIZE));
            ctx.fillStyle = "#FFB8FF";
            dots.forEach(d => {
                if(d.active) {
                    ctx.beginPath();
                    ctx.arc(d.x * TILE_SIZE + TILE_SIZE/2, d.y * TILE_SIZE + TILE_SIZE/2, 2, 0, Math.PI*2);
                    ctx.fill();
                }
            });
            ctx.fillStyle = "#FFFF00";
            ctx.beginPath();
            let mouth = (Date.now() % 200 < 100) ? 0.2 : 0.05;
            let rotation = 0;
            if(pacman.dir === 0) rotation = -Math.PI/2;
            if(pacman.dir === 2) rotation = Math.PI/2;
            if(pacman.dir === 3) rotation = Math.PI;
            ctx.translate(pacman.currentX * TILE_SIZE + TILE_SIZE/2, pacman.currentY * TILE_SIZE + TILE_SIZE/2);
            ctx.rotate(rotation);
            ctx.arc(0, 0, TILE_SIZE/2 - 2, mouth * Math.PI, (2 - mouth) * Math.PI);
            ctx.lineTo(0, 0);
            ctx.fill();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ghosts.forEach(g => {
                ctx.fillStyle = g.color;
                ctx.beginPath();
                const gx = g.currentX * TILE_SIZE;
                const gy = g.currentY * TILE_SIZE;
                ctx.arc(gx + TILE_SIZE/2, gy + TILE_SIZE/2 - 2, TILE_SIZE/2 - 2, Math.PI, 0);
                ctx.lineTo(gx + TILE_SIZE, gy + TILE_SIZE - 2);
                ctx.lineTo(gx, gy + TILE_SIZE - 2);
                ctx.fill();
            });
        }

        function updateScore() {
            document.getElementById('score-display').innerText = "SCORE: " + score;
        }

        function checkWin() {
            if(dots.every(d => !d.active)) {
                alert("YOU WIN! SCORE: " + score);
                resetLevel();
                score = 0;
                updateScore();
            }
        }

        function gameOver() {
            alert("GAME OVER! SCORE: " + score);
            resetLevel();
            score = 0;
            updateScore();
        }

        // Auto-start
        initGame();

    </script>
</body>
</html>
