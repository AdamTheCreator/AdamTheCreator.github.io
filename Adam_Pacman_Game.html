<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ADAM'S PAC-MAN CHALLENGE</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --pac-yellow: #FFFF00;
            --ghost-red: #FF0000;
            --ghost-pink: #FFB8FF;
            --ghost-cyan: #00FFFF;
            --ghost-orange: #FFB852;
            --wall-blue: #1919A6;
            --bg-black: #000000;
        }

        body {
            background-color: var(--bg-black);
            color: #FFFFFF;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        #game-area {
            position: relative;
            width: 95%;
            max-width: 400px;
            text-align: center;
        }

        canvas {
            background-color: #000;
            display: block;
            margin: 0 auto;
            border: 2px solid var(--wall-blue);
            box-shadow: 0 0 15px var(--wall-blue);
            max-width: 100%;
            height: auto;
        }

        #game-ui {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 380px;
            margin: 0 auto 15px auto;
            font-size: 12px;
            color: var(--pac-yellow);
            padding: 0 5px;
            box-sizing: border-box;
        }

        #game-instructions {
            font-size: 10px;
            color: #666;
            margin-top: 15px;
            text-transform: uppercase;
        }

        .btn {
            margin-top: 20px;
            padding: 15px 20px;
            border: 2px solid #FFF;
            background: #000;
            color: #FFF;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: background 0.2s;
        }
        .btn:hover { background: #333; }

        /* NAME INPUT MODAL */
        #name-modal, #game-over-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .hidden { display: none !important; }

        input[type="text"] {
            background: #000;
            border: 2px solid var(--wall-blue);
            color: var(--pac-yellow);
            font-family: 'Press Start 2P', cursive;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            margin: 20px 0;
            text-transform: uppercase;
        }
        
        .modal-box {
            border: 4px double var(--wall-blue);
            padding: 30px;
            text-align: center;
            background: #000;
        }

    </style>
</head>
<body>

    <!-- UI HUD -->
    <div id="game-ui">
        <div id="score-display">SCORE: 0</div>
        <div>PLAYER: <span id="player-name-display">???</span></div>
    </div>

    <!-- GAME CANVAS -->
    <div id="game-area">
        <canvas id="gameCanvas" width="380" height="300"></canvas>
    </div>

    <div id="game-instructions">ARROWS OR SWIPE TO MOVE</div>
    <div style="font-size: 8px; color: #444; margin-top: 5px;">LEVEL: REAL LIFE (HARD)</div>

    <a href="index.html" class="btn">BACK TO MENU</a>

    <!-- NAME INPUT MODAL -->
    <div id="name-modal">
        <div class="modal-box">
            <h2 style="color: var(--ghost-cyan); font-size: 16px; margin-bottom: 20px;">IDENTIFY YOURSELF</h2>
            <p style="font-size: 10px; color: #AAA;">ENTER PLAYER NAME:</p>
            <input type="text" id="player-name-input" maxlength="8" placeholder="ADAM" autofocus>
            <br>
            <button class="btn" onclick="startGame()">INSERT COIN</button>
        </div>
    </div>

    <!-- GAME OVER / WIN MODAL -->
    <div id="game-over-modal" class="hidden">
        <div class="modal-box">
            <h2 id="modal-title" style="color: var(--ghost-red); font-size: 20px; margin-bottom: 20px;">GAME OVER</h2>
            <p id="modal-score" style="font-size: 12px; color: var(--pac-yellow); margin-bottom: 30px;">SCORE: 0</p>
            
            <button class="btn" onclick="restartGame()">TRY AGAIN?</button>
            <br>
            <a href="index.html" class="btn" style="border-color: #555; color: #888;">QUIT TO MENU</a>
        </div>
    </div>

    <script>
        // --- GAME ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 20;
        const COLS = 19;
        const ROWS = 15;
        let gameRunning = false;
        let score = 0;
        let playerName = "ADAM";

        // Map: 1=Wall, 0=Dot, 2=Empty/PacStart, 9=GhostStart
        const mapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,9,2,9,2,2,1,0,1,2,2,2], 
            [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1], 
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let walls = [];
        let dots = [];
        let pacman = {};
        let ghosts = [];
        
        // Touch variables
        let touchStartX = 0;
        let touchStartY = 0;

        function startGame() {
            const inputName = document.getElementById('player-name-input').value;
            if(inputName.trim() !== "") playerName = inputName.toUpperCase();
            document.getElementById('player-name-display').innerText = playerName;
            document.getElementById('name-modal').classList.add('hidden');
            
            initGame();
        }

        function initGame() {
            resetLevel();
            score = 0;
            updateScore();
            gameRunning = true;
            
            window.addEventListener('keydown', handleInput);
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            
            requestAnimationFrame(gameLoop);
        }
        
        function restartGame() {
            document.getElementById('game-over-modal').classList.add('hidden');
            initGame();
        }

        function resetLevel() {
            walls = [];
            dots = [];
            for(let r=0; r<ROWS; r++){
                for(let c=0; c<COLS; c++){
                    if(mapLayout[r][c] === 1) walls.push({x:c, y:r});
                    if(mapLayout[r][c] === 0) dots.push({x:c, y:r, active:true});
                }
            }
            pacman = { x: 9, y: 13, dir: 4, nextDir: 4, speed: 0.08, moveProgress: 0, currentX: 9, currentY: 13 };
            ghosts = [
                { x: 9, y: 7, color: 'red', dir: 1, speed: 0.055, moveProgress: 0, currentX: 9, currentY: 7 }, // Slightly faster for "Real Life"
                { x: 10, y: 7, color: 'pink', dir: 3, speed: 0.055, moveProgress: 0, currentX: 10, currentY: 7 }
            ];
        }

        function handleInput(e) {
            if([37,38,39,40].indexOf(e.keyCode) > -1) e.preventDefault();
            if(e.keyCode === 38) pacman.nextDir = 0; 
            if(e.keyCode === 39) pacman.nextDir = 1; 
            if(e.keyCode === 40) pacman.nextDir = 2; 
            if(e.keyCode === 37) pacman.nextDir = 3; 
        }

        function handleTouchStart(e) {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if(!touchStartX || !touchStartY) return;
            let touchEndX = e.touches[0].clientX;
            let touchEndY = e.touches[0].clientY;
            let dx = touchEndX - touchStartX;
            let dy = touchEndY - touchStartY;
            
            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0) pacman.nextDir = 1; 
                    else pacman.nextDir = 3;
                } else {
                    if (dy > 0) pacman.nextDir = 2; 
                    else pacman.nextDir = 0;
                }
                touchStartX = touchEndX;
                touchStartY = touchEndY;
            }
        }

        function gameLoop() {
            if(!gameRunning) return;
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            moveEntity(pacman, true);
            ghosts.forEach(g => {
                if (g.moveProgress === 0 && isIntersection(g.x, g.y)) {
                    const dirs = getValidDirections(g.x, g.y);
                    g.dir = dirs[Math.floor(Math.random() * dirs.length)];
                }
                if (isBlocked(g.x, g.y, g.dir) && g.moveProgress === 0) {
                     const dirs = getValidDirections(g.x, g.y);
                     g.dir = dirs[Math.floor(Math.random() * dirs.length)];
                }
                moveEntity(g, false);
            });

            ghosts.forEach(g => {
                const dist = Math.hypot(pacman.currentX - g.currentX, pacman.currentY - g.currentY);
                if(dist < 0.5) triggerGameOver(false);
            });

            dots.forEach(d => {
                if(d.active) {
                    const dist = Math.hypot(pacman.currentX - d.x, pacman.currentY - d.y);
                    if(dist < 0.5) {
                        d.active = false;
                        score += 10;
                        updateScore();
                        checkWin();
                    }
                }
            });
        }

        function moveEntity(e, isPlayer) {
            if (e.moveProgress > 0) {
                e.moveProgress += e.speed;
                if (e.moveProgress >= 1) {
                    e.moveProgress = 0;
                    if(e.dir === 0) e.y--;
                    if(e.dir === 1) e.x++;
                    if(e.dir === 2) e.y++;
                    if(e.dir === 3) e.x--;
                    e.currentX = e.x;
                    e.currentY = e.y;
                    if(isPlayer) {
                        if(e.nextDir !== 4 && !isBlocked(e.x, e.y, e.nextDir)) e.dir = e.nextDir;
                        else if (isBlocked(e.x, e.y, e.dir)) e.dir = 4;
                    }
                } else {
                    if(e.dir === 0) e.currentY = e.y - e.moveProgress;
                    if(e.dir === 1) e.currentX = e.x + e.moveProgress;
                    if(e.dir === 2) e.currentY = e.y + e.moveProgress;
                    if(e.dir === 3) e.currentX = e.x - e.moveProgress;
                }
            } else {
                if(isPlayer && e.nextDir !== 4 && !isBlocked(e.x, e.y, e.nextDir)) e.dir = e.nextDir;
                if (e.dir !== 4 && !isBlocked(e.x, e.y, e.dir)) e.moveProgress += e.speed;
            }
        }

        function isBlocked(x, y, dir) {
            let nextX = x, nextY = y;
            if(dir === 0) nextY--;
            if(dir === 1) nextX++;
            if(dir === 2) nextY++;
            if(dir === 3) nextX--;
            if(nextX < 0 || nextX >= COLS || nextY < 0 || nextY >= ROWS) return true;
            return walls.some(w => w.x === nextX && w.y === nextY);
        }

        function isIntersection(x, y) {
            let open = 0;
            if(!isBlocked(x, y, 0)) open++;
            if(!isBlocked(x, y, 1)) open++;
            if(!isBlocked(x, y, 2)) open++;
            if(!isBlocked(x, y, 3)) open++;
            return open > 2;
        }

        function getValidDirections(x, y) {
            const dirs = [];
            if(!isBlocked(x, y, 0)) dirs.push(0);
            if(!isBlocked(x, y, 1)) dirs.push(1);
            if(!isBlocked(x, y, 2)) dirs.push(2);
            if(!isBlocked(x, y, 3)) dirs.push(3);
            return dirs;
        }

        function draw() {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#1919A6";
            walls.forEach(w => ctx.fillRect(w.x * TILE_SIZE, w.y * TILE_SIZE, TILE_SIZE, TILE_SIZE));
            ctx.fillStyle = "#FFB8FF";
            dots.forEach(d => {
                if(d.active) {
                    ctx.beginPath();
                    ctx.arc(d.x * TILE_SIZE + TILE_SIZE/2, d.y * TILE_SIZE + TILE_SIZE/2, 2, 0, Math.PI*2);
                    ctx.fill();
                }
            });
            ctx.fillStyle = "#FFFF00";
            ctx.beginPath();
            let mouth = (Date.now() % 200 < 100) ? 0.2 : 0.05;
            let rotation = 0;
            if(pacman.dir === 0) rotation = -Math.PI/2;
            if(pacman.dir === 2) rotation = Math.PI/2;
            if(pacman.dir === 3) rotation = Math.PI;
            ctx.translate(pacman.currentX * TILE_SIZE + TILE_SIZE/2, pacman.currentY * TILE_SIZE + TILE_SIZE/2);
            ctx.rotate(rotation);
            ctx.arc(0, 0, TILE_SIZE/2 - 2, mouth * Math.PI, (2 - mouth) * Math.PI);
            ctx.lineTo(0, 0);
            ctx.fill();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ghosts.forEach(g => {
                ctx.fillStyle = g.color;
                ctx.beginPath();
                const gx = g.currentX * TILE_SIZE;
                const gy = g.currentY * TILE_SIZE;
                ctx.arc(gx + TILE_SIZE/2, gy + TILE_SIZE/2 - 2, TILE_SIZE/2 - 2, Math.PI, 0);
                ctx.lineTo(gx + TILE_SIZE, gy + TILE_SIZE - 2);
                ctx.lineTo(gx, gy + TILE_SIZE - 2);
                ctx.fill();
            });
        }

        function updateScore() {
            document.getElementById('score-display').innerText = "SCORE: " + score;
        }

        function checkWin() {
            if(dots.every(d => !d.active)) {
                triggerGameOver(true);
            }
        }

        function triggerGameOver(win) {
            gameRunning = false;
            const modal = document.getElementById('game-over-modal');
            const title = document.getElementById('modal-title');
            const scoreText = document.getElementById('modal-score');
            
            modal.classList.remove('hidden');
            scoreText.innerText = "SCORE: " + score;
            
            if(win) {
                title.innerText = "MISSION ACCOMPLISHED!";
                title.style.color = "#00FF00";
            } else {
                title.innerText = "GAME OVER";
                title.style.color = "#FF0000";
            }
        }

    </script>
</body>
</html>
